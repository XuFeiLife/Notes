# 介绍

**连接查询（Joins）** 是将两个或多个表中的行根据共有列（通常是外键）组合在一起的核心操作。你可以把它想象成拼图，通过寻找匹配的边缘，把散落在不同表里的信息拼凑成一张完整的视图。

# 表结构和数据

```sql
-- 创建用户表

CREATE TABLE users (

id INT PRIMARY KEY,

name VARCHAR(50)

);

  

-- 创建订单表

CREATE TABLE orders (

order_id INT PRIMARY KEY,

user_id INT, -- 外键，关联 users.id

amount DECIMAL(10, 2)

);

  

-- 插入数据

INSERT INTO users VALUES (1, '小王'), (2, '老李'), (3, '阿强');

INSERT INTO orders VALUES (101, 1, 250.00), (102, 1, 100.00), (103, 2, 500.00), (104, 99, 50.00);
```

```
|id |name|
|---|----|
|1  |小王  |
|2  |老李  |
|3  |阿强  |

|order_id|user_id|amount|
|--------|-------|------|
|101     |1      |250   |
|102     |1      |100   |
|103     |2      |500   |
|104     |99     |50    |


```
# 内连接(INNER JOIN)

这是最常用的连接类型。它只返回两个表中**完全匹配**的行。如果某行在另一个表中没有对应项，则会被过滤掉。

- **场景**：只想查看“既有订单又有客户详情”的数据。
- **示例**：
```sql
SELECT u.name, o.order_id, o.amount

FROM users u

INNER JOIN orders o ON u.id = o.user_id;
```

结果：只有小王和老李。阿强（没订单）和 104 号订单（用户 ID 99 不在用户表）都被排除了。
```
|name|order_id|amount|
|----|--------|------|
|小王  |101     |250   |
|小王  |102     |100   |
|老李  |103     |500   |
```

# 左外连接(LEFT OUTER JOIN)

返回**左表（FROM 之后的表）的所有行**。如果右表中有匹配项，则显示；如果没有，右表的列将显示为 `NULL`。

- **场景**：列出所有用户，哪怕他们从来没下过订单（没下单的用户订单金额显示为 NULL）。
- **示例**：
```sql
SELECT u.name, o.order_id, o.amount

FROM users u

LEFT JOIN orders o ON u.id = o.user_id;
```

结果：包含所有用户。你会看到**阿强**出现在名单里，但他的 `order_id` 是 `NULL`。
```
|name|order_id|amount|
|----|--------|------|
|小王  |101     |250   |
|小王  |102     |100   |
|老李  |103     |500   |
|阿强  |null    |null  |


```

# 右外连接 (RIGHT OUTER JOIN)

与左连接相反，返回**右表的所有行**。

- **场景**：虽然在 PostgreSQL 中通常用 `LEFT JOIN` 代替（只需调换表顺序），但在某些多表复杂查询中，它可以方便地保留右侧主表的数据。
- 示例：
```sql
SELECT u.name, o.order_id, o.amount

FROM users u

RIGHT JOIN orders o ON u.id = o.user_id;

```

结果：你会看到 **104 号订单**，但其对应的 `name` 是 `NULL`（因为用户 99 不存在）。
```TEXT
|name|order_id|amount|
|----|--------|------|
|小王  |101     |250   |
|小王  |102     |100   |
|老李  |103     |500   |
|null  |104     |50    |


```

# 全外连接/全连接 (FULL OUTER JOIN)

只要其中一个表存在匹配，就返回行。它是左连接和右连接的结合体。

- **场景**：当你需要两张表的并集，找出所有存在的信息，无论它们是否互相关联。
- **示例**：找出所有的员工和所有的项目，包括没有分配项目的员工以及没有负责人的项目。
```sql
SELECT u.name, o.order_id, o.amount

FROM users u

FULL JOIN orders o ON u.id = o.user_id;
```

结果：阿强在（带 NULL 订单），104 号订单也在（带 NULL 用户）。
```text
|name|order_id|amount|
|----|--------|------|
|小王  |101     |250   |
|小王  |102     |100   |
|老李  |103     |500   |
|null  |104    |50    |
|阿强  | null   |null  |

```

# 自连接(SELF JOIN)

表与其自身进行连接。这不是一种新的连接类型，而是 `JOIN` 的一种特殊用法（需要给表起别名）。

- **场景**：处理层级结构，比如“员工表”里有一列是“经理 ID”，而经理本身也是员工。

# 对比

| **连接类型**       | **包含的内容**           | **排除的内容**        |
| -------------- | ------------------- | ---------------- |
| **INNER JOIN** | 只有下了单的用户            | 没下单的人 + 找不到主人的订单 |
| **LEFT JOIN**  | **所有用户**，包括没下单的     | 找不到主人的订单         |
| **RIGHT JOIN** | **所有订单**，包括没录入系统的用户 | 没下单的用户           |
| **FULL JOIN**  | **所有数据**            | 无                |