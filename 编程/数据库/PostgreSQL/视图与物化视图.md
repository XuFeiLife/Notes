# 视图(View)

视图本质上是一个**存储在数据库中的 SQL 查询语句**。当你查询视图时，数据库实际上是在后台重新运行那段 SQL 逻辑。

- **特点**：不占用存储空间（只存 SQL 定义），数据始终是**实时**的。
- **优点**：
    - **安全性**：可以隐藏敏感列（如不给财务视图看用户密码）。
    - **简化查询**：把嵌套了 5 个表的连接查询封装成一个简单的 `SELECT * FROM my_view`。
- **示例**：
```sql
CREATE VIEW active_user_orders AS
SELECT u.name, o.amount, o.order_id
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.status = 'active';
```

# 物化视图 (Materialized View) 

- **特点**：占用磁盘空间，数据是**非实时**的（存在延迟）。**物化视图不会自动刷新**
- **优点**：
    - **极高性能**：对于涉及百万级数据聚合（如 `SUM`, `AVG`）的报表，物化视图可以将查询时间从几分钟缩短到几毫秒。
    - **可建索引**：你可以像给普通表建索引一样，给物化视图建索引。

# 对比

| **特性**    | **视图 (View)**   | **物化视图 (Materialized View)** |
| --------- | --------------- | ---------------------------- |
| **存储**    | 仅存储 SQL 语句（虚拟）  | 存储实际数据（物理）                   |
| **数据实时性** | **实时**（随原表同步变化） | **非实时**（取决于刷新频率）             |
| **查询性能**  | 取决于底层查询的复杂程度    | **极快**（直接读取磁盘结果）             |
| **索引**    | 不支持独立索引         | **支持索引**                     |
| **维护成本**  | 无（自动）           | 需要手动或定时刷新                    |

# 刷新物化视图

因为物化视图的数据是静态的，所以当原始表数据更新后，物化视图的数据会“过时”。你需要通过 `REFRESH` 命令来更新它：

```sql
-- 全量刷新（刷新期间会锁表，无法查询）
REFRESH MATERIALIZED VIEW my_report_view;

-- 增量/并发刷新（不影响查询，但需要物化视图上有唯一索引）
CREATE UNIQUE INDEX idx_order_id ON my_report_view (order_id);
REFRESH MATERIALIZED VIEW CONCURRENTLY my_report_view;
```

自动刷新方案
PostgreSQL 原生并不支持类似“每隔 5 分钟自动刷新物化视图”的配置。通常的做法是：
- Linux Crontab
  ```bash
  psql -c "REFRESH MATERIALIZED VIEW CONCURRENTLY user_order_summary;"
  ```
- pg_cron（推荐）
  ```sql
  -- 安装扩展（通常由管理员操作） 
  CREATE EXTENSION pg_cron;
  
  -- 定时任务
  SELECT cron.schedule(
    'refresh_user_order_summary', --任务名称
    '*/10 * * * *',
    'REFRESH MATERIALIZED VIEW CONCURRENTLY user_order_summary'
);
  ```
  