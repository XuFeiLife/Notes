
```java
public ThreadPoolExecutor(int corePoolSize,  
                          int maximumPoolSize,  
                          long keepAliveTime,  
                          TimeUnit unit,  
                          BlockingQueue<Runnable> workQueue) {  
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,  
         Executors.defaultThreadFactory(), defaultHandler);  
}
```

在 Java 的并发编程中，`ThreadPoolExecutor` 是线程池的核心实现类。理解它的 **7 大参数**是优化系统性能、防止资源耗尽的关键。

你可以把线程池想象成一个外包公司：

----
### 1. corePoolSize（核心线程数）

- **定义**：线程池中的常驻核心线程数。
- **类比**：公司的**正式员工**。即便没活干，他们也会留在公司待命。只有当任务量超过核心线程数时，才会考虑开启更多策略。

### 2. maximumPoolSize（最大线程数）

- **定义**：线程池能够容纳的最大线程数量。
- **类比**：正式员工 + **临时工**的总和。当任务实在太多，正式员工忙不过来且阻塞队列也满了，公司就会雇佣临时工。

### 3. keepAliveTime（空闲线程存活时间）

- **定义**：多余的空闲线程（即临时工）能存活的时间。
- **类比**：临时工没活干之后，观察多久才辞退。如果在这段时间内没有新任务，临时工就会被解雇。

### 4. unit（时间单位）

- **定义**：`keepAliveTime` 的时间单位（如秒、毫秒）。

### 5. workQueue（任务阻塞队列）

- **定义**：存放等待执行任务的队列。
- **类比**：公司的**候客区/待办列表**。当正式员工都在忙时，新来的任务会先去排队。
- **常见类型**：`LinkedBlockingQueue`（链表）、`ArrayBlockingQueue`（数组）。

### 6. threadFactory（线程工厂）

- **定义**：用于创建线程的工厂。
- **类比**：**人力资源部（HR）**。主要负责给线程起个好听的名字（方便排查日志）、设置优先级等。

### 7. handler（拒绝策略）

- **定义**：当队列满了且线程数也达到了最大值时，如何处理新来的任务。
- **类比**：**拒收函**。
- **常见策略**：
    
    - `AbortPolicy`（默认）：直接抛异常，不干了。
    - `CallerRunsPolicy`：让提交任务的那个线程（老板自己）去执行。
    - `DiscardOldestPolicy`：把队列里排最久的删掉，尝试接纳新的。
    - `DiscardPolicy`：直接丢弃，不报错。

---

### 💡 线程池的工作流程总结

1. **提交任务** → 2. **核心线程**未满？创建核心线程执行。
2. 核心线程满了 → 3. **阻塞队列**未满？存入队列等待。
3. 队列也满了 → 4. **最大线程数**未满？创建非核心线程（临时工）执行。
4. 最大线程也满了 → 5. 执行**拒绝策略**。



