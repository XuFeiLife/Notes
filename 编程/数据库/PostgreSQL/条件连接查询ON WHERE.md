# 介绍

在连接查询中添加条件时，最关键的是要分清：**这个条件是放在 `ON` 子句中，还是放在 `WHERE` 子句中？** 虽然结果有时看起来一样，但对于**外连接 (LEFT/RIGHT JOIN)**，这两者的逻辑差异巨大。

我们继续沿用之前的 `users` 和 `orders` 表。[连接查询](连接查询.md)

# ON子句加条件

`ON` 条件决定了**如何匹配**两个表。如果条件不满足，对于外连接来说，左表的数据依然会保留，只是右表部分显示为 `NULL`。

**场景**：列出所有用户，但只关联金额大于 200 的订单。

```sql
SELECT u.name, o.amount

FROM users u

LEFT JOIN orders o ON u.id = o.user_id AND o.amount > 200;
```

**结果**：

- 小王（有 250 元订单）：匹配成功，显示 250。
- 小王（有 100 元订单）：匹配失败（不满足 > 200），但因为是 `LEFT JOIN`，小王这条记录还在，只是该行的 `amount` 显示为 `NULL`。
- 老李、阿强：同理，不满足条件的订单都会导致显示 `NULL`。
```
|name|amount|
|----|------|
|小王  |250   |
|老李  |500   |
|阿强  |null  |

```
# WHERE子句加条件

`WHERE` 是在**连接完成后**对整个结果集进行过滤。如果不满足 `WHERE` 条件，整行数据都会被删掉。

**场景**：查询所有用户，但在最后的结果中只要那些金额大于 200 的记录。

```sql
SELECT u.name, o.amount

FROM users u

LEFT JOIN orders o ON u.id = o.user_id

WHERE o.amount > 200;
```

**结果**：

- 这个查询实际上**变成了内连接**的效果。
- 阿强（amount 是 NULL）和 100 元的小订单会被过滤掉，因为 `NULL > 200` 的结果是 Unknown，不会通过过滤。
```
|name|amount|
|----|------|
|小王  |250   |
|老李  |500   |

```

# 连接后的聚合条件 (`GROUP BY` + `HAVING`)

当你需要根据连接后的数据进行统计分析时，这非常有用。

**场景**：找出订单总额超过 300 元的用户。

```sql
SELECT u.name, SUM(o.amount) AS total_spent

FROM users u

JOIN orders o ON u.id = o.user_id

GROUP BY u.name

HAVING SUM(o.amount) > 300;
```

**逻辑**：先连接，再按姓名分组，最后过滤掉总和不达标的人。
```
|name|total_spent|
|----|-----------|
|老李  |500        |
|小王  |350        |

```

# 对比

| **场景**               | **使用 ON**                         | **使用 WHERE**                     |
| -------------------- | --------------------------------- | -------------------------------- |
| **内连接 (INNER)**      | 效果一致，通常写在 `ON` 里。                 | 效果一致。                            |
| **外连接 (LEFT/RIGHT)** | **影响匹配过程**。不满足条件的右表变 NULL，但左表行还在。 | **影响最终结果**。不满足条件的整行（包括左表数据）都会消失。 |