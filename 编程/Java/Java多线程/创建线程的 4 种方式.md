1. [**继承 Thread（不推荐）**](创建线程的%204%20种方式.md#**继承%20Thread（不推荐）**)
2. [**实现Runnable（推荐）**](创建线程的%204%20种方式.md#**实现Runnable（推荐）**)
3. [**实现Callable+Future（有返回值）**](创建线程的%204%20种方式.md#**实现Callable+Future（有返回值）**)
4. [**线程池（实际项目首选）**](创建线程的%204%20种方式.md#**线程池（实际项目首选）**)
### **继承 Thread（不推荐）**

``` java
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("running...");
    }
}

new MyThread().start();

```
Java 单继承，扩展性差

### **实现Runnable（推荐）**

```java
class MyTask implements Runnable {
    @Override
    public void run() {
        System.out.println("running...");
    }
}

new Thread(new MyTask()).start();

```

### **实现Callable+Future（有返回值）**

```java
Callable<Integer> task = () -> {
    Thread.sleep(1000);
    return 42;
};

FutureTask<Integer> future = new FutureTask<>(task);
new Thread(future).start();

Integer result = future.get(); // 阻塞获取结果

```
异步计算， 需要返回值 和异常处理

### **线程池（实际项目首选）**

[为什么推荐ThreadPoolExecutor来创建线程](为什么推荐ThreadPoolExecutor来创建线程.md)


```java
ExecutorService pool = Executors.newFixedThreadPool(5);

pool.submit(() -> {
    System.out.println("task running");
});

pool.shutdown();

```