设置线程数没有“万能公式”，因为设置得太小，CPU 会闲着（资源浪费）；设置得太大，线程之间反复切换上下文（Context Switch），反而会让系统变慢。

最科学的方法是根据**任务的性质**来分情况讨论：

---

### 1. CPU 密集型任务

- **特征**：任务主要是复杂的计算、逻辑处理、加密解码。这类任务对 CPU 的利用率极高。

- **配置公式**：**$N_{CPU} + 1$**
    
    - $N_{CPU}$ 表示 CPU 的核心数（可以通过 `Runtime.getRuntime().availableProcessors()` 获取）。
        
    - **为什么要 +1？** 为了防止某个线程因为偶尔的“页缺失”或其他异常暂停，多出的这一个线程可以立刻顶上，保证 CPU 始终满载。
        

### 2. I/O 密集型任务

- **特征**：任务涉及大量的网络请求、数据库读写、文件操作。这种情况下，线程大部分时间都在“等”结果，CPU 比较闲。
    
- **常用经验值**：**$2 \times N_{CPU}$**
    
- **进阶公式（更精准）**：
    
    $$线程数 = N_{CPU} \times \left(1 + \frac{线程等待时间}{线程计算时间}\right)$$
    
    - 如果一个任务 90% 的时间在等 I/O，10% 的时间在计算，那么线程数可以设为 $10 \times (1 + 9/1) = 100$。
        

---

### 3. 动态调整策略（美团等大厂实践）

在现实开发中，很难精准预估“等待时间”和“计算时间”。目前主流的高级做法是：**不写死参数，动态监控调整**。

1. **参数参数化**：将 `corePoolSize` 和 `maximumPoolSize` 存放在配置中心（如 Apollo、Nacos）。
    
2. **动态刷新**：利用 `ThreadPoolExecutor` 提供的 `setCorePoolSize()` 等方法，在程序运行时实时修改线程数。
    
3. **监控打点**：监控队列长度、活跃线程数和拒绝策略的触发次数。如果发现队列经常满，就调大一点；如果 CPU 飙升到 90%，就调小一点。
    

---

### 核心建议：压测才是真理

无论公式多完美，都建议通过**压力测试**来验证：

- **低负载**：观察响应时间（RT）。
    
- **高负载**：观察吞吐量（TPS）和 CPU 占用率。
    

---

### 避坑指南

- **不要用 `Executors.newFixedThreadPool`**：它的请求队列长度是 `Integer.MAX_VALUE`，任务堆积时容易导致 **OOM (内存溢出)**。
    
- **一定要自定义线程池**：手动给线程起名字，出问题看堆栈日志时能一眼认出是谁。