“唯一约束必须包含分区键”是很多数据库（特别是支持声明式分区的系统）在分区表上的硬性要求，最典型的就是 MySQL、PostgreSQL（原生分区表）、OceanBase、PolarDB for PG 早期版本等。

# 核心原因

因为这些数据库在分区表上实现的**唯一约束 / 主键** 默认使用的是**局部索引（Local Index）**，而不是全局索引（Global Index）。

- 局部索引：每个分区独立维护一份索引结构
- 只在**同一个分区内**能保证唯一性
- 如果唯一约束的字段**不包含分区键**，数据库就无法判断跨分区的重复值（因为它不会去扫描所有分区）

因此为了让数据库**在不扫描全表**的情况下就能强制执行唯一性，就强制要求：**唯一约束的字段必须包含所有分区键列**。

典型报错示例
```sql
-- PostgreSQL

CREATE TABLE orders (

id bigserial,

created_at timestamptz,

UNIQUE (id) -- 报错

) PARTITION BY RANGE (created_at);
```

```text
SQL Error [0A000]: ERROR: unique constraint on partitioned table must include all partitioning columns
  Detail: UNIQUE constraint on table "orders" lacks column "created_at" which is part of the partition key.
```

# 常见解决方案

| 方案            | 做法示例                       | 优点             | 缺点                 | 适用场景           |
| ------------- | -------------------------- | -------------- | ------------------ | -------------- |
| 1. 把分区键加入唯一约束 | UNIQUE KEY (user_id, dt)   | 性能最好，局部索引      | 业务上可能接受不了复合唯一      | 业务允许按分区键+业务键唯一 |
| 2. 把分区键加入主键   | PRIMARY KEY (id, dt)       | 简单，MySQL最常见做法  | 主键变长，索引占用空间增大      | 大多数业务表         |
| 3. 使用全局唯一索引   | （PolarDB PG、OceanBase部分支持） | 真正全局唯一，不用改业务字段 | 性能差、写入放大、维护复杂      | 必须全局唯一且无法改模型   |
| 4. 去掉唯一约束     | 业务层或触发器/应用层去重              | 模型最灵活          | 容易出脏数据，维护成本高       | 对唯一性要求不高       |
| 5. 改用逻辑分区/不分区 | 不使用数据库原生分区                 | 约束最自由          | 失去分区剪枝、过期数据快速删除等优势 | 数据量可控或对性能要求不高  |